
<div class="two-column underlined">
    <div class="content">
        <div>
            The Z80 architecture is quite special to me. For one, it's the
            processor used in the <a href="https://en.wikipedia.org/wiki/TI-84_Plus_series">TI-84 plus</a>
            calculator. My <a href="https://qcpu.qsmally.org">initial QCPU 2 architecture</a>
            design is heavily influenced by the Z80, apart from the instruction
            set, before I opted for a full 16-bit RISC V-like architecture.
        </div>

        <p>
        That aside, I'm quite interested in kernels (as indicated by
        <a href="https://qcpu.qsmally.org">QOS</a>) so it makes sense that I'll
        be attempting to write a simple one for it. Ideally, my vision is to
        interface with a terminal (with UART through a <a href="Z8440.pdf">SIO</a>)
        and create a binary loader (through a <a href="Z8410.pdf">DMA</a>).
        From there, new software can be serialised into SRAM and ran
        immediately, without having to write to an EEPROM.
        </p>

        <p>
        As frontend to this operating system, I'm going to attempt to
        recreate <a href="/posts/6502">Wozmon</a> (Apple I software for the
        6502) on the Z80.
        </p>

        <p class="text-tiny-section">Part list</p>

        <p>
        I'm using the 6 MHz specs of all the Z84Cxx components, except for the
        CTC (which is an NMOS spec):
        </p>

        <ul>
            <li><a href="Z8400.pdf">Z84C00 (CMOS, 6 MHz) 'Z80 CPU'</a></li>
            <li><a href="Z8420.pdf">Z84C20 (CMOS, 6 MHz) 'PIO' (Parallel Input/Output)</a></li>
            <li><a href="Z8430.pdf">Z84C30 (NMOS, 6 MHz) 'CTC' (Counter/Timer Circuit)</a></li>
            <li><a href="Z8440.pdf">Z84C40 (CMOS, 6 MHz) 'SIO/0' (Serial Input/Output)</a></li>
            <li><a href="W27C020.pdf">W27C020 (256 KiB) EEPROM</a></li>
            <li><a href="AS6C1008-55PCN.pdf">AS6C1008 (128 KiB) SRAM</a></li>
            <li><a href="sn74ls32.pdf">SN74LS32N ORs</a></li>
            <li><a href="sn74hc14.pdf">SN74HC14N Hex Inverters</a></li>
            <li><a href="sn74hcs238.pdf">SN74HC238N 3-to-8 Line Decoder</a></li>
        </ul>

        <p>
        Now, I'm running this system on a 4 MHz crystal oscillator. I also have
        a 1.8432 MHz crystal oscillator tied to the trigger inputs of the CTC
        for the first three channels. The fourth channel trigger input is tied
        to the trigger output of the third channel. The trigger inputs are used
        whilst in counter mode, and allow me to use them for flexible baudrate
        generation. Channels 0 and 1 of the CTC are tied to the clocks of SIO
        channels A and B, respectively.
        </p>

        <p class="text-tiny-section">Memory map</p>

        <p>
        For those who are unfamiliar with the Z80 address space, and unlike
        most other CPUs around that time, the Z80 has separate memory and I/O
        spaces. This is indicated by the <code>MREQ</code> and
        <code>IOREQ</code> control lines from the CPU.
        </p>

        <p>
        In the memory range, I set up the memory map so writable RAM takes up
        the majority of space. This is for the reason I stated before, as I'd
        like to upload programs through a loader into RAM. So:
        </p>

        <ul>
            <li><code>0000 - 3FFF : </code>EEPROM (16k)</li>
            <li><code>4000 - FFFF : </code>SRAM (48k)</li>
        </ul>

        <p>
        Conversely, the I/O space is only 8 bit, rather than the full memory
        address range of 16 bits. The Z80 implemented it like this essentially
        due to the <code>OTIR</code>-like instructions, which use register
        <code>B</code> for byte countdown, and register <code>C</code> for the
        I/O address. In any case, the upper 3 bits of the address are decoded:
        </p>

        <ul>
            <li><code>0b101xxxxx : </code>PIO</li>
            <li><code>0b110xxxxx : </code>SIO</li>
            <li><code>0b111xxxxx : </code>CTC</li>
        </ul>
    </div>

    <div class="sidebar list">
        <img src="thumbnail.jpg" alt="Z80 breadboard computer"/>
    </div>
</div>

<div class="two-column underlined">
    <div class="content">
        <div class="text-subtext">2025-12-28</div>
        <div class="text-tiny-section">Wozmon for the Z80 family</div>

        <p>
        Wozmon is the original software that came with the Apple I. I ran it on
        my <a href="/posts/6502">6502</a> breadboard project. Now, one with a
        few brain cells might realise that the Apple I isn't made with the Z80
        CPU. A short superficial research shows that few have recreated it, but
        it seemed fun to do so, too.
        </p>

        <p>
        My Wozmon, or <a href="https://github.com/QSmally/ZMon">ZMon</a> as I'd
        like to call it, uses at the time of writing 253 bytes of EEPROM,
        <em>without initialisation of I/O</em>. That last bit costs another
        40-ish bytes because the SIO needs quite a lot of bytes in sequence for
        it to be set up.
        </p>

        <p>
        This hex monitor allows you to now write programs in hexadecimal and
        jump to them. For example, <code>3E</code> is the opcode for <code>ld
        a, n</code>, <code>D3</code> for <code>out (n), a</code>, and
        <code>C3</code> for the absolute jump instruction.
        </p>
    </div>

    <div class="sidebar list">
        <img src="wozmon.jpg" alt="Wozmon for the Z80 family"/>
    </div>
</div>

<div class="two-column underlined">
    <div class="content">
        <div class="text-subtext">2026-01-15</div>
        <div class="text-tiny-section">Quest to add the Z80 DMA</div>

        <p>
        My goal of this Z80 <em>System on a Breadboard</em> (SoB) is to allow
        you to upload a binary file and immediately write it to RAM using a
        loader. This way, you can program it without rewriting the EEPROM, just
        through the UART connection with the SIO.
        </p>

        <p>
        Today, I was able to collect the Z80 DMA that I had ordered:
        </p>

        <ul>
            <li><a href="Z8410.pdf">Z84C10 (CMOS, 4 MHz) 'DMA' (Direct Memory Access)</a></li>
        </ul>

        <p>
        I've registered the DMA peripheral at the following I/O address:
        </p>

        <ul>
            <li><code>0b100xxxxx : </code>DMA</li>
        </ul>

        <p>
        I had to add another breadboard in order to fit the DMA. In the first
        picture, the DMA can be seen at the top. It connects to the control
        wires from the Z80 CPU, as well as bus request and bus acknowledge, and
        the address and data buses.
        </p>

        <p>
        To test the DMA, I wrote a trivial program at address <code>1000</code>
        (in EEPROM) which copies 256 bytes from <code>5000</code> to
        <code>6000</code> (in RAM) and jumps back to ZMon. In the second
        picture, the addresses are first assessed before calling
        <code>1000R</code> (jumping to the DMA copy routine), after which the
        addresses are printed out again, which shows that the DMA transferred
        the source range to the destination range. I also wrote a program
        (which is not depicted) that receives 16 bytes from an I/O port, which
        tests the SIO's ready line to the DMA. This allows the SIO to trigger
        DMA transfers from the I/O peripheral and sync it to memory
        automatically, without CPU intervention.
        </p>

        <p>
        Maybe I'll add another DMA for SIO Channel A, in order to use it for
        other purposes like disk transfers (if I'll ever create that). In any
        case, this direct transfer method allows me to (not easily, but more
        neatly) create a file loader. In contrast, I can now transfer entire
        ASCII files to the SIO without having to stall the CPU due to SIO
        lag (transmission delay).
        </p>
    </div>

    <div class="sidebar list">
        <img src="dma-system.jpg" alt="The new system layout with a DMA at the top"/>
        <img src="dma-memory.jpg" alt="DMA transfer depicted in ZMon"/>
    </div>
</div>
